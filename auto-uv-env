#!/usr/bin/env bash
# auto-uv-env - Automatic UV-based Python environment management
# https://github.com/ashwch/auto-uv-env
#
# Copyright (c) 2024 Ashwini Chaudhary
# Licensed under the MIT License

set -euo pipefail

VERSION="1.0.5"
QUIET_MODE="${AUTO_UV_ENV_QUIET:-0}"
DEBUG_MODE="${AUTO_UV_ENV_DEBUG:-0}"

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[0;33m'
NC='\033[0m' # No Color

# Print colored output unless in quiet mode
print_status() {
    [[ "$QUIET_MODE" == "1" ]] && return
    echo -e "${BLUE}üêç${NC} $1" >&2
}

print_success() {
    [[ "$QUIET_MODE" == "1" ]] && return
    echo -e "${GREEN}‚úÖ${NC} $1" >&2
}

print_error() {
    echo -e "${RED}‚ùå${NC} $1" >&2
}

print_debug() {
    [[ "$DEBUG_MODE" == "1" ]] || return 0
    echo -e "${YELLOW}üîç${NC} DEBUG: $1" >&2
}

print_deactivate() {
    [[ "$QUIET_MODE" == "1" ]] && return
    echo -e "${YELLOW}‚¨áÔ∏è${NC}  $1" >&2
}

# Validate and set venv directory name
validate_venv_name() {
    local name="${AUTO_UV_ENV_VENV_NAME:-.venv}"
    # Ensure no path separators or parent directory references
    if [[ "$name" =~ [/\\] ]] || [[ "$name" == *".."* ]]; then
        print_error "Invalid venv name: $name (cannot contain path separators or ..)"
        exit 1
    fi
    echo "$name"
}

VENV_DIR="$(validate_venv_name)"

# Check if UV is available with helpful suggestions
check_uv() {
    if ! command -v uv >/dev/null 2>&1; then
        print_error 'auto-uv-env: UV not found.'
        echo "Install options:" >&2
        echo "  ‚Ä¢ curl -LsSf https://astral.sh/uv/install.sh | sh" >&2
        echo "  ‚Ä¢ brew install uv" >&2
        echo "  ‚Ä¢ pip install uv" >&2
        exit 1
    fi

    # Check UV version for compatibility warnings
    local uv_version
    uv_version=$(uv --version 2>/dev/null | cut -d' ' -f2)
    if [[ -n "$uv_version" ]]; then
        # Warn about very old UV versions (< 0.1.0 is ancient)
        if [[ "$uv_version" < "0.1.0" ]]; then
            print_error "Warning: UV version $uv_version is very old. Consider upgrading."
        fi
    fi
}

# Validate Python version format
validate_python_version() {
    local version="$1"
    if [[ -z "$version" ]]; then
        return 1
    fi
    # Strict validation: only allow X.Y or X.Y.Z format
    if [[ ! "$version" =~ ^[0-9]+\.[0-9]+(\.[0-9]+)?$ ]]; then
        print_error "Invalid Python version format: $version"
        return 1
    fi
    echo "$version"
}

# Parse Python version from pyproject.toml with robust error handling
get_python_version() {
    local project_file="$1/pyproject.toml"
    [[ -f "$project_file" ]] || return 1

    # Validate file is readable
    if [[ ! -r "$project_file" ]]; then
        print_error "Cannot read $project_file (permission denied)"
        return 1
    fi

    # Try different patterns for Python version specification
    local version
    version=$(grep -E "requires-python|python_requires" "$project_file" 2>/dev/null |
              sed -E 's/.*[">]=?([0-9]+\.[0-9]+(\.[0-9]+)?).*/\1/' |
              head -1)

    # Handle empty/malformed file
    if [[ -z "$version" ]]; then
        # Try alternative patterns
        version=$(python -c "import tomllib; print(tomllib.load(open('$project_file', 'rb')).get('project', {}).get('requires-python', '').replace('>=', '').replace('~=', '').strip())" 2>/dev/null || echo "")
    fi

    # Validate the extracted version
    if validate_python_version "$version" >/dev/null 2>&1; then
        echo "$version"
    else
        return 1
    fi
}

# Main directory check function
check_directory() {
    local dir="${1:-$PWD}"

    print_debug "Checking directory: $dir"
    print_debug "VENV_DIR: $VENV_DIR"

    # Quick exit if disabled or no pyproject.toml
    if [[ -f "$dir/.auto-uv-env-ignore" ]]; then
        print_debug "auto-uv-env disabled in $dir (.auto-uv-env-ignore found)"
        return 0
    fi

    if [[ ! -f "$dir/pyproject.toml" ]]; then
        print_debug "No pyproject.toml found in $dir"
        # Check if we need to deactivate
        if [[ -n "${VIRTUAL_ENV:-}" ]]; then
            print_debug "Deactivating current environment: $VIRTUAL_ENV"
            echo "DEACTIVATE=1"
        fi
        return 0
    fi

    local venv_path="$dir/$VENV_DIR"
    local py_version
    py_version=$(get_python_version "$dir" 2>/dev/null || echo "")

    print_debug "Virtual environment path: $venv_path"
    print_debug "Detected Python version: ${py_version:-none}"

    # Create venv if needed
    if [[ ! -d "$venv_path" ]]; then
        echo "CREATE_VENV=1"
        if [[ -n "$py_version" ]]; then
            echo "PYTHON_VERSION=$py_version"
            echo "MSG_SETUP=üêç Setting up Python $py_version with UV..."
        else
            echo "MSG_SETUP=üêç Creating UV environment..."
        fi
    fi

    # Activate if needed
    if [[ -f "$venv_path/bin/activate" ]] && [[ "${VIRTUAL_ENV:-}" != "$venv_path" ]]; then
        echo "ACTIVATE=$venv_path"
    elif [[ ! -f "$venv_path/bin/activate" ]] && [[ ! -d "$venv_path" ]]; then
        # Venv creation is needed and will be handled by shell integration
        :
    fi
}

# Diagnose environment and configuration
diagnose_environment() {
    local dir="${1:-$PWD}"
    echo "auto-uv-env diagnostic report"
    echo "============================"
    echo "Version: $VERSION"
    echo "Directory: $dir"
    echo "Timestamp: $(date)"
    echo ""

    # Check UV installation
    echo "UV Status:"
    if command -v uv >/dev/null 2>&1; then
        echo "‚úÖ UV found: $(which uv)"
        echo "‚ÑπÔ∏è UV version: $(uv --version 2>/dev/null || echo 'unknown')"
    else
        echo "‚ùå UV not found"
    fi
    echo ""

    # Check Python installation
    echo "Python Status:"
    if command -v python >/dev/null 2>&1; then
        echo "‚úÖ Python found: $(which python)"
        echo "‚ÑπÔ∏è Python version: $(python --version 2>/dev/null || echo 'unknown')"
    else
        echo "‚ùå Python not found"
    fi
    echo ""

    # Check project structure
    echo "Project Structure:"
    if [[ -f "$dir/pyproject.toml" ]]; then
        echo "‚úÖ pyproject.toml found"
        local py_version
        py_version=$(get_python_version "$dir" 2>/dev/null || echo "")
        if [[ -n "$py_version" ]]; then
            echo "‚ÑπÔ∏è Required Python: $py_version"
        else
            echo "‚ö†Ô∏è  No requires-python found in pyproject.toml"
        fi
    else
        echo "‚ùå No pyproject.toml found"
    fi

    local venv_path="$dir/$VENV_DIR"
    if [[ -d "$venv_path" ]]; then
        echo "‚úÖ Virtual environment exists: $venv_path"
        if [[ -f "$venv_path/bin/activate" ]]; then
            echo "‚úÖ Activation script found"
        else
            echo "‚ùå Activation script missing"
        fi
    else
        echo "‚ÑπÔ∏è Virtual environment not created yet: $venv_path"
    fi
    echo ""

    # Check environment variables
    echo "Environment Variables:"
    echo "‚ÑπÔ∏è AUTO_UV_ENV_QUIET: ${AUTO_UV_ENV_QUIET:-unset}"
    echo "‚ÑπÔ∏è AUTO_UV_ENV_DEBUG: ${AUTO_UV_ENV_DEBUG:-unset}"
    echo "‚ÑπÔ∏è AUTO_UV_ENV_VENV_NAME: ${AUTO_UV_ENV_VENV_NAME:-unset (using .venv)}"
    echo "‚ÑπÔ∏è VIRTUAL_ENV: ${VIRTUAL_ENV:-unset}"
    echo ""

    # Check shell integration
    echo "Shell Integration:"
    echo "‚ÑπÔ∏è Current shell: ${SHELL:-unknown}"

    # Check for common issues
    echo "Common Issues Check:"
    if [[ ! -w "$dir" ]]; then
        echo "‚ö†Ô∏è  Directory not writable: $dir"
    fi

    if [[ -f "$dir/pyproject.toml" ]] && [[ ! -r "$dir/pyproject.toml" ]]; then
        echo "‚ö†Ô∏è  pyproject.toml not readable"
    fi

    local temp_test="/tmp/auto-uv-env-test.$$"
    if ! touch "$temp_test" 2>/dev/null; then
        echo "‚ö†Ô∏è  Cannot write to /tmp (state files will fail)"
    else
        rm -f "$temp_test"
    fi

    echo "
Diagnostic complete."
}

# Validate version consistency across all files
validate_versions() {
    local script_version="$VERSION"
    local errors=0

    echo "Validating version consistency..."
    echo "Script version: $script_version"

    # Check pyproject.toml
    if [[ -f "pyproject.toml" ]]; then
        if grep -q "version = \"$script_version\"" pyproject.toml; then
            echo "‚úÖ pyproject.toml version matches"
        else
            echo "‚ùå pyproject.toml version mismatch"
            errors=$((errors + 1))
        fi
    else
        echo "‚ö†Ô∏è  pyproject.toml not found"
    fi

    # Check CHANGELOG.md
    if [[ -f "CHANGELOG.md" ]]; then
        if grep -q "\[$script_version\]" CHANGELOG.md; then
            echo "‚úÖ CHANGELOG.md contains version"
        else
            echo "‚ùå CHANGELOG.md missing version [$script_version]"
            errors=$((errors + 1))
        fi
    else
        echo "‚ö†Ô∏è  CHANGELOG.md not found"
    fi

    # Check Homebrew formula
    if [[ -f "homebrew/auto-uv-env.rb" ]]; then
        if grep -q "v$script_version" homebrew/auto-uv-env.rb; then
            echo "‚úÖ Homebrew formula version matches"
        else
            echo "‚ùå Homebrew formula version mismatch"
            errors=$((errors + 1))
        fi
    else
        echo "‚ö†Ô∏è  Homebrew formula not found"
    fi

    if [[ $errors -eq 0 ]]; then
        echo "üéâ All version checks passed!"
        return 0
    else
        echo "üí• $errors version inconsistencies found"
        return 1
    fi
}

# Show help
show_help() {
    cat << EOF
auto-uv-env - Automatic UV Python environment management

Version: $VERSION
Author: Ashwini Chaudhary (https://github.com/ashwch)

USAGE:
    auto-uv-env [OPTIONS]
    auto-uv-env --check-safe [DIRECTORY]

OPTIONS:
    --check-safe [DIR]  Check and activate UV environment in directory (safe mode)
    --validate          Validate version consistency across all project files
    --diagnose [DIR]    Show diagnostic information for debugging
    --version, -v       Show version information
    --help, -h          Show this help message

SHELL INTEGRATION:
    For zsh (~/.zshrc):
        source \$(brew --prefix)/share/auto-uv-env/auto-uv-env.zsh

    For bash (~/.bashrc):
        source \$(brew --prefix)/share/auto-uv-env/auto-uv-env.bash

    For fish (~/.config/fish/config.fish):
        source \$(brew --prefix)/share/auto-uv-env/auto-uv-env.fish

ENVIRONMENT VARIABLES:
    AUTO_UV_ENV_QUIET=1        Suppress status messages
    AUTO_UV_ENV_DEBUG=1        Enable debug output
    AUTO_UV_ENV_VENV_NAME=dir  Use custom venv directory (default: .venv)

DISABLING:
    Create .auto-uv-env-ignore file in any directory to disable auto-uv-env

REQUIREMENTS:
    - UV (https://github.com/astral-sh/uv)
    - pyproject.toml in project directory

EXAMPLES:
    # Diagnose current directory
    auto-uv-env --diagnose

    # Validate version consistency
    auto-uv-env --validate

    # Use with debug mode
    AUTO_UV_ENV_DEBUG=1 auto-uv-env --diagnose

For more information, visit: https://github.com/ashwch/auto-uv-env
EOF
}

# Main CLI handling
case "${1:-}" in
    --version|-v)
        echo "auto-uv-env $VERSION"
        # Ensure output is flushed before exit to prevent broken pipe
        sleep 0.001 2>/dev/null || true
        exit 0
        ;;
    --check)
        # Legacy mode - deprecated, use --check-safe instead
        print_error "Deprecated: --check mode removed for security. Use shell integration."
        exit 1
        ;;
    --check-safe)
        # Safe mode using standard output
        check_uv
        check_directory "${2:-$PWD}"
        ;;
    --validate)
        validate_versions
        exit $?
        ;;
    --diagnose)
        diagnose_environment "${2:-$PWD}"
        exit $?
        ;;
    --help|-h)
        show_help
        exit 0
        ;;
    "")
        # No arguments - show help
        show_help
        exit 0
        ;;
    *)
        echo "Unknown option: $1"
        echo "Use --help for usage information"
        exit 1
        ;;
esac
